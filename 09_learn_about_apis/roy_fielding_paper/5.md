# 第 5 章 REST（Representational State Transfer）について

本章では、分散型ハイパーメディアシステムのアーキテクチャスタイルである REST（Representational State Transfer）を紹介し、REST を導くソフトウェア工学の原則と、その原則を維持するために選択されたインタラクション制約を、他のアーキテクチャスタイルの制約と対比させながら説明しています。REST は、第 3 章で説明したネットワークベースのアーキテクチャスタイルのいくつかから派生したハイブリッドスタイルで、統一されたコネクタインターフェースを定義する追加の制約を組み合わせたものです。第 1 章のソフトウェア・アーキテクチャ・フレームワークを使用して、REST のアーキテクチャ要素を定義し、プロトタイプ・アーキテクチャのプロセス、コネクタ、およびデータ・ビューのサンプルを検証します。

## 5.1 REST の派生

Web アーキテクチャの背後にある設計上の根拠は、アーキテクチャ内の要素に適用される一連の制約からなるアーキテクチャスタイルによって説明することができます。進化するスタイルに追加された各制約の影響を調べることで、ウェブの制約によって誘発される特性を特定することができます。その後、追加の制約を適用することで、現代のウェブアーキテクチャに求められる特性をよりよく反映した新しいアーキテクチャスタイルを形成することができます。このセクションでは、REST をアーキテクチャスタイルとして導き出すプロセスを紹介しながら、REST の概要を説明します。後のセクションでは、REST スタイルを構成する特定の制約条件について、より詳細に説明します。

### 5.1.1 ヌル式で始める

建築物であれソフトウェアであれ、建築設計のプロセスには 2 つの共通した考え方があります。1 つ目は、設計者は何もない状態（白紙の状態、ホワイトボード、製図板など）からスタートし、意図するシステムのニーズを満たすまで、身近なコンポーネントからアーキテクチャを構築していくというものです。2 つ目は、設計者がシステムのニーズを制約なしに全体として把握することから始め、設計空間を区別し、システムの動作に影響を与える力がシステムと調和して自然に流れるようにするために、システムの要素を段階的に特定して制約を適用することです。前者が創造性と無限のビジョンを重視するのに対し、後者は抑制とシステムコンテキストの理解を重視します。REST は後者のプロセスで開発されました。図 5-1 から図 5-8 は、適用された制約が、制約の漸進的なセットを適用する際に、アーキテクチャのプロセスビューをどのように差別化するかという観点から、これを図式化したものです。

Null スタイル（図 5-1）は、単に制約の空のセットです。アーキテクチャの観点から見ると、Null スタイルは、コンポーネント間に識別可能な境界が存在しないシステムを表しています。このスタイルは、REST の説明の出発点となっています。

### 5.1.2 クライアント-サーバー

ハイブリッドスタイルに追加された最初の制約は、セクション 3.4.1 で説明したクライアント・サーバ・アーキテクチャ・スタイル（図 5-2）の制約です。「懸念事項の分離」は、クライアント・サーバ型の制約の原則です。ユーザーインターフェースの問題をデータストレージの問題から分離することで、複数のプラットフォームにまたがるユーザーインターフェースの移植性を向上させ、サーバーコンポーネントを単純化することでスケーラビリティを向上させます。しかし、Web にとって最も重要なことは、分離することでコンポーネントを独立して進化させることができ、複数の組織ドメインのインターネット規模の要件をサポートすることができることです。

### 5.1.3 ステートレス

クライアントからサーバーへの各リクエストには、そのリクエストを理解するために必要なすべての情報が含まれていなければならず、サーバーに保存されているコンテキストを利用することはできません。そのため、セッションの状態はすべてクライアント側で保持されます。

この制約により、可視性、信頼性、およびスケーラビリティという特性が得られます。可視性は，監視システムがリクエストの完全な性質を判断するために，単一のリクエストデータを超えて調べる必要がないため，改善されます．信頼性は，部分的な故障からの回復作業が容易になるため，改善されます [133]．スケーラビリティが向上します．これは，リクエスト間で状態を保存する必要がないため，サーバコンポーネントが迅速にリソースを解放することができるからです．また，サーバがリクエスト間のリソース使用を管理する必要がないため，実装がさらにシンプルになります．

ほとんどのアーキテクチャの選択と同様に、ステートレス制約は設計上のトレードオフを反映しています。デメリットとしては、一連のリクエストで送信される反復的なデータ（インタラクションごとのオーバーヘッド）が増えることで、ネットワークパフォーマンスが低下する可能性があります。また、アプリケーションの状態をクライアント側に置くと、アプリケーションが複数のクライアントのバージョンでセマンティクスが正しく実装されているかどうかに依存することになるため、アプリケーションの一貫した動作に対するサーバのコントロールが弱くなります。

### 5.1.4 キャッシュ

ネットワーク効率を向上させるために、キャッシュ制約を追加して、セクション 3.4.4 のクライアント-キャッシュ-ステートレス-サーバのスタイルを形成する（図 5-4）。キャッシュ制約は、リクエストに対するレスポンス内のデータを、暗黙的または明示的にキャッシュ可能または非キャッシュ可能とラベル付けすることを要求する。レスポンスがキャッシュ可能であれば、クライアントキャッシュには、そのレスポンスデータを後の同等のリクエストに再利用する権利が与えられる。

キャッシュ制約を追加する利点は、一部のインタラクションを部分的または完全に排除できる可能性があり、一連のインタラクションの平均レイテンシーを短縮することで、効率性、スケーラビリティ、およびユーザーが感じるパフォーマンスを向上させることができることです。しかし、トレードオフとして、キャッシュ内の古いデータが、リクエストがサーバに直接送信された場合に得られたであろうデータと著しく異なる場合、キャッシュは信頼性を低下させる可能性があります。

図 5-5[11]の図に示されているように、初期の Web アーキテクチャは、クライアント-キャッシュ-ステートレス-サーバの一連の制約によって定義されていました。つまり、1994 年以前の Web アーキテクチャの設計根拠は、インターネット上で静的なドキュメントを交換するための、ステートレスなクライアントとサーバーの相互作用に焦点を当てていました。相互通信のためのプロトコルは、非共有キャッシュを初歩的にサポートしていましたが、すべてのリソースに対して一貫したセマンティクスのセットにインターフェイスを制約するものではありませんでした。その代わり、Web アプリケーション間の一貫性を維持するために、Web は共通のクライアント-サーバ実装ライブラリ（CERN libwww）の使用に依存していました。

ウェブ実装の開発者は、すでに初期の設計を超えていた。静的なドキュメントに加えて、リクエストは、イメージマップ[Kevin Hughes]やサーバーサイドスクリプト[Rob McCool]など、動的にレスポンスを生成するサービスを特定することができました。また、プロキシ[79]や共有キャッシュ[59]といった形で、仲介コンポーネントの開発も始まっていましたが、これらのコンポーネントが確実に通信するためには、プロトコルの拡張が必要でした。以下のセクションでは、現代のウェブアーキテクチャを形成する拡張機能を導くために、ウェブのアーキテクチャスタイルに加えられた制約について説明します。

### 5.1.5 統一されたフォーマット

REST のアーキテクチャスタイルを他のネットワークベースのスタイルと区別する中心的な特徴は、コンポーネント間の統一されたインターフェースを重視していることです（図 5-6）。ソフトウェアエンジニアリングの原則である汎用性をコンポーネントのインターフェースに適用することで、システム全体のアーキテクチャが簡素化され、相互作用の可視性が向上します。また、実装とサービスが切り離されているため、独立した進化が可能になります。しかし、アプリケーションのニーズに合わせて情報を転送するのではなく、標準化された形式で情報を転送するため、統一されたインターフェースは効率性を低下させるというトレードオフがあります。REST インターフェースは、大規模なハイパーメディアのデータ転送に効率的に対応できるように設計されており、Web という一般的なケースに最適化されていますが、結果的に他の形式のアーキテクチャの対話には最適ではないインターフェースとなっています。

統一されたインターフェースを実現するためには、コンポーネントの動作を導くための複数のアーキテクチャ制約が必要です。REST は、「リソースの識別」「表現によるリソースの操作」「自己記述的なメッセージ」「アプリケーション状態のエンジンとしてのハイパーメディア」という 4 つのインターフェース制約によって定義されています。これらの制約条件については、セクション 5.2 で説明します。

### 5.1.6 レイヤードシステム

インターネット規模の要件に対する動作をさらに改善するために、レイヤードシステム制約を追加しました（図 5-7）。セクション 3.4.2 で説明したように、レイヤードシステムのスタイルでは、各コンポーネントが相互作用している直近のレイヤを超えて「見る」ことができないようにコンポーネントの動作を制約することで、アーキテクチャを階層的なレイヤで構成することができます。システムに関する知識を 1 つの層に限定することで、システム全体の複雑さに制限をかけ、基板の独立性を高めることができます。レイヤーは、従来のサービスをカプセル化したり、新しいサービスを従来のクライアントから保護したりするために使用され、使用頻度の低い機能を共有の仲介物に移すことで、コンポーネントを簡素化することができる。また、中間体を利用することで、複数のネットワークやプロセッサにまたがるサービスの負荷分散を可能にし、システムのスケーラビリティを向上させることができます。

レイヤーシステムの主な欠点は、データの処理にオーバーヘッドとレイテンシーが加わり、ユーザーが知覚するパフォーマンスが低下することです[32]。キャッシュ制約をサポートするネットワークベースのシステムでは、中間層での共有キャッシュの利点により、この問題は相殺されます。共有キャッシュを組織ドメインの境界に配置することで、パフォーマンスが大幅に向上します[136]。また、このような層は、ファイアウォールで必要とされるように、組織の境界を越えるデータにセキュリティポリシーを適用することを可能にします[79]。

レイヤーシステムと均一なインターフェース制約の組み合わせは、均一なパイプとフィルターのスタイル（セクション 3.2.2）と同様のアーキテクチャ特性を誘発します。REST のインタラクションは双方向ですが、ハイパーメディアのインタラクションの大粒のデータフローは、それぞれデータフローネットワークのように処理することができ、フィルタコンポーネントをデータストリームに選択的に適用して、通過するコンテンツを変換することができます [26]。REST では、メッセージが自己記述的であり、そのセマンティクスが仲介者に見えるため、仲介コンポーネントはメッセージのコンテンツを積極的に変換することができる。

### 5.1.7 コード・オン・デマンド

REST の制約条件に最後に加わるのは、セクション 3.5.3 のコード・オン・デマンドのスタイルです（図 5-8）。REST では、アプレットやスクリプトの形でコードをダウンロードして実行することで、クライアントの機能を拡張することができます。これにより、事前に実装しなければならない機能の数が減り、クライアントがシンプルになります。デプロイ後に機能をダウンロードできるようにすることで、システムの拡張性が向上する。しかし、視認性が低下するため、REST では任意の制約となっています。

任意制約という概念は、一見矛盾しているように思えるかもしれません。しかし、複数の組織境界を包含するシステムのアーキテクチャ設計においては、目的があります。それは、システム全体のある領域に対してオプションの制約が有効であることがわかっている場合にのみ、アーキテクチャがオプションの制約の恩恵を受ける（デメリットを被る）ということです。たとえば、ある組織内のすべてのクライアントソフトウェアが Java アプレットをサポートしていることがわかっている場合[45]、その組織内のサービスは、ダウンロード可能な Java クラスによって強化された機能の恩恵を受けるように構築することができます。しかし、同時に、組織のファイアウォールが外部ソースからの Java アプレットの転送を妨げる可能性があり、したがって、ウェブの他の部分からは、それらのクライアントがコードオンデマンドをサポートしていないように見えることになる。任意の制約を設けることで、一般的なケースでは望ましい動作をサポートするアーキテクチャを設計することができますが、コンテキストによってはそれが無効になる可能性があることを理解しておく必要があります。

### 5.1.8 スタイル派生の概要

REST は、候補となるアーキテクチャに誘発する特性のために選ばれた一連のアーキテクチャ制約から構成されています。これらの制約はそれぞれ単独で考えることができますが、一般的なアーキテクチャスタイルからの派生という観点で説明することで、その選択の根拠を理解しやすくなります。図 5-9 は、第 3 章で検討したネットワークベースのアーキテクチャスタイルの観点から、REST の制約条件の導出を図示したものです。

## 5.2 REST のアーキテクチャ要素

REST（Representational State Transfer）スタイルは、分散ハイパーメディアシステム内のアーキテクチャ要素を抽象化したものです。REST は、コンポーネントの役割、他のコンポーネントとの相互作用の制約、重要なデータ要素の解釈に焦点を当てるため、コンポーネントの実装やプロトコル構文の詳細を無視しています。REST は、コンポーネント、コネクタ、データに対する基本的な制約を網羅しており、これが Web アーキテクチャの基礎を定義し、したがってネットワークベースのアプリケーションとしての動作の本質となっています。

### 5.2.1 データ要素

すべてのデータが処理コンポーネントの中にカプセル化されて隠されている分散オブジェクトスタイル[31]とは異なり、アーキテクチャのデータ要素の性質と状態は REST の重要な側面です。この設計の合理性は、分散型ハイパーメディアの性質に見ることができます。リンクが選択されると、情報は保存されている場所から、ほとんどの場合、人間の読者によって使用される場所に移動する必要があります。これは、他の多くの分散処理パラダイム[6, 50]とは異なり、「処理エージェント」（モバイルコード、ストアドプロシージャ、検索式など）を、データを処理装置に移動させるのではなく、データに移動させることが可能であり、通常、より効率的である。

分散ハイパーメディアの設計者には、基本的に 3 つの選択肢しかありません。1）データが配置されている場所でデータをレンダリングし、固定フォーマットの画像を受信者に送信する、2）データをレンダリングエンジンでカプセル化し、その両方を受信者に送信する、3）生データにデータタイプを記述したメタデータを添付して受信者に送信し、受信者が自分でレンダリングエンジンを選択できるようにする。

それぞれの方法にはメリットとデメリットがあります。1）の伝統的なクライアント・サーバ方式[31]では、データの本質に関するすべての情報を送信者側に隠すことができるため、データ構造についての推測ができず、クライアントの実装が容易になります。しかし，受信側の機能が極端に制限され，処理負荷のほとんどが送信側にかかるため，スケーラビリティの問題が生じます．オプション 2 のモバイル・オブジェクト・スタイル[50]は、独自のレンダリング・エンジンによってデータの特殊な処理を可能にしつつ、情報の隠蔽を実現しますが、受信者の機能はそのエンジン内で想定されるものに限定され、転送されるデータの量が大幅に増加する可能性があります。オプション 3 は、送信者がシンプルでスケーラブルな状態を維持しつつ、転送されるデータ量を最小限に抑えることができますが、情報隠蔽の利点は失われ、送信者と受信者の両方が同じデータタイプを理解する必要があります。

REST は、3 つのオプションのハイブリッドを提供しています。データタイプの理解をメタデータで共有することに焦点を当てていますが、明かされる範囲は標準化されたインターフェイスに限定されています。REST コンポーネントは、受信者の能力や要望、およびリソースの性質に基づいて動的に選択された、進化する標準データタイプのいずれかに一致するフォーマットで、リソースの表現を転送することによって通信します。表現が生のソースと同じフォーマットであるか、ソースから派生したものであるかは、インターフェースの後ろに隠されています。モバイル・オブジェクト・スタイルの利点は、カプセル化されたレンダリング・エンジン（Java[45]など）の標準データ形式の命令で構成された表現を送信することで近似します。したがって、REST は、サーバーのスケーラビリティ問題を伴わないクライアント・サーバースタイルの関心事の分離を獲得し、サービスのカプセル化と進化を可能にする汎用インターフェースによる情報の隠蔽を可能にし、ダウンロード可能な機能エンジンによる多様な機能セットを提供します。

REST のデータ要素を表 5-1 にまとめました。

| データ要素         | モダンな web 事例                                |
| ------------------ | ------------------------------------------------ |
| リソース           | ハイパーテキスト参照の意図された概念的ターゲット |
| リソース識別子     | URL, URN                                         |
| 表現               | HTML 文書, JPEG 画像                             |
| 表現メタデータ     | media type、last-modified time                   |
| リソースメタデータ | source link, alternates, バリエーション（vary）  |
| コントロールデータ | if-modified-since, cache-control（http ヘッダ）  |

#### 5.2.1.1 リソースとリソース識別子

REST における情報の主要な抽象化はリソースです。ドキュメントや画像、一時的なサービス（例：「ロサンゼルスの今日の天気」）、他のリソースのコレクション、仮想ではないオブジェクト（例：人）など、名前を付けることができる情報はすべてリソースになります。言い換えれば、作者がハイパーテキストで参照する対象となる可能性のある概念はすべて、リソースの定義に当てはまらなければなりません。リソースとは、一連の実体に対する概念的なマッピングであり、特定の時点でマッピングに対応する実体ではない。

より正確には、リソース R は、時間的に変化するメンバーシップ関数 MR(t)であり、時間 t に対して、等価なエンティティのセット、または値をマッピングする。セット内の値は、リソースの表現やリソースの識別子であってもよい。リソースは空のセットにマップすることができ、これにより、概念の実現が存在する前に、その概念を参照することができる。リソースの中には、作成後にいつでも調べられるという意味で静的なものもあります。他のものは、時間の経過とともにその価値が高度に変化していく。リソースが静的であることが求められるのは、マッピングのセマンティクスだけです。セマンティクスは、あるリソースと別のリソースを区別するものだからです。

例えば、学術論文の「author's preferred version」は時間とともに価値が変化するマッピングですが、「the paper published in the proceedings of conference X」へのマッピングは静的です。これらは、たとえどちらもある時点では同じ価値にマッピングされるとしても、2 つの異なるリソースです。この区別は、両方のリソースを独立して識別および参照できるようにするために必要です。ソフトウェアエンジニアリングの同様の例として、バージョン管理されたソースコードファイルを、"最新のリビジョン"、"リビジョン番号 1.2.7"、"Orange リリースに含まれるリビジョン "のように区別して参照することが挙げられます。

このようにリソースを抽象的に定義することで、Web アーキテクチャの主要な機能を実現しています。第一に、多くの情報源を人為的にタイプや実装で区別することなく包含することで、汎用性を提供します。第二に、参照を表現に後から結合することができ、リクエストの特性に基づいてコンテンツネゴシエーションを行うことができます。最後に、REST では、作者が概念の単一の表現ではなく概念を参照することができるため、表現が変わるたびに既存のリンクをすべて変更する必要がありません（作者が正しい識別子を使用していると仮定した場合）。

REST では、コンポーネント間の相互作用に関わる特定のリソースを識別するために、リソース識別子を使用しています。REST コネクタは、メンバーシップ関数がどのように定義されているか、またはリクエストを処理するソフトウェアのタイプに関係なく、リソースの値セットにアクセスして操作するための汎用的なインターフェースを提供します。リソース識別子を割り当ててリソースの参照を可能にしたネーミングオーソリティは、マッピングの意味的な妥当性を長期にわたって維持する（すなわち、メンバーシップ関数が変更されないようにする）責任を負います。

従来のハイパーテキストシステム[61]は、通常、閉じた環境やローカルな環境で動作しており、情報が変わるたびに変更されるユニークなノードやドキュメントの識別子を使用し、リンクサーバに依存してコンテンツとは別に参照を維持しています[135]。一元化されたリンクサーバは、Web の巨大なスケールと複数の組織のドメイン要件には無縁であるため、REST では代わりに、作者が識別される概念の性質に最も適したリソース識別子を選択することに依存しています。当然のことながら、識別子の品質は、その有効性を維持するために費やされた金額に比例することが多く、その結果、刹那的な（あるいはサポートが不十分な）情報が時間の経過とともに移動したり消滅したりして、リンク切れが発生します。

#### 5.2.1.2 表現

REST コンポーネントは、リソースの現在の状態または意図された状態をキャプチャするために表現を使用し、コンポーネント間でその表現を転送することによって、リソースに対してアクションを実行します。表現とは、一連のバイトと、そのバイトを記述する表現メタデータのことである。表現の名称としては、ドキュメント、ファイル、HTTP メッセージのエンティティ、インスタンス、バリアントなどが一般的に使用されていますが、正確ではありません。

表現は、データと、そのデータを記述するメタデータと、場合によってはそのメタデータを記述するメタデータ（通常はメッセージの整合性を検証する目的で使用される）から構成される。メタデータは、名前と値のペアの形をしており、名前は値の構造とセマンティクスを定義する規格に対応しています。応答メッセージには、表現メタデータとリソースメタデータ（提供された表現に固有ではないリソースに関する情報）の両方が含まれることがあります。

制御データは、リクエストされるアクションやレスポンスの意味など、コンポーネント間のメッセージの目的を定義します。コントロールデータは、リクエストをパラメータ化したり、一部の接続要素のデフォルトの動作を上書きするためにも使用されます。例えば、キャッシュの動作は、リクエストやレスポンスのメッセージに含まれる制御データによって変更することができます。

メッセージの制御データに応じて、ある表現は、要求されたリソースの現在の状態、要求されたリソースに対する望ましい状態、あるいは、クライアントの問い合わせフォーム内の入力データの表現や、応答に対する何らかのエラー条件の表現など、他のリソースの値を示すことがあります。例えば、リソースのリモートオーサリングでは、オーサリング者がサーバに表現を送信することで、後のリクエストで取得可能なリソースの値を確立する必要があります。ある時点でのリソースの値セットが複数の表現で構成されている場合、コンテントネゴシエーションを使用して、与えられたメッセージに含める最適な表現を選択することができます。

表現のデータ形式はメディアタイプと呼ばれています[48]。表現はメッセージに含めることができ、メッセージの制御データとメディアタイプの性質に応じて受信者が処理することができます。メディアタイプには、自動処理を目的としたものと、ユーザが閲覧するためにレンダリングすることを目的としたものがあり、その両方が可能なものもある。複合メディアタイプは、1 つのメッセージに複数の表現を含めるために使用できます。

メディアタイプの設計は、分散ハイパーメディアシステムのユーザーが感じるパフォーマンスに直接影響を与えます。受信者が表現のレンダリングを開始する前に受信しなければならないデータがあると、インタラクションの待ち時間が長くなります。最も重要なレンダリング情報を前面に配置し、残りの情報を受信している間に最初の情報を段階的にレンダリングできるようなデータフォーマットは、レンダリングを開始する前にすべてを受信しなければならないデータフォーマットよりも、ユーザーが知覚するパフォーマンスがはるかに優れています。

例えば、大きな HTML 文書を受信しながら段階的にレンダリングできるウェブブラウザは、ネットワーク性能は同じでも、文書全体を完全に受信してからレンダリングするウェブブラウザよりも、ユーザーが知覚する性能が大幅に向上します。なお、表現のレンダリング能力は、コンテンツの選択によっても影響を受けます。動的なサイズのテーブルや埋め込みオブジェクトの寸法をレンダリング前に決定しなければならない場合、ハイパーメディアページの表示領域内にこれらのオブジェクトが存在すると、レイテンシーが増加します。

### 5.2.2 コネクター

REST では、表 5-2 に示すようなさまざまなタイプのコネクタを使用して、リソースへのアクセスやリソース表現の転送などのアクティビティをカプセル化しています。コネクタは、コンポーネントの通信のための抽象的なインターフェースを提供し、関心事を明確に分離し、リソースや通信メカニズムの基本的な実装を隠すことで、シンプルさを向上させます。また、インターフェイスの汎用性は、代替性を可能にします。ユーザーがシステムにアクセスする唯一の手段が抽象的なインターフェイスを介したものであれば、ユーザーに影響を与えることなく実装を置き換えることができます。また、コネクタはコンポーネントのネットワーク通信を管理するため、複数のインタラクションで情報を共有することができ、効率と応答性を向上させることができます。

| コネクタ | モダンな web 事例                   |
| -------- | ----------------------------------- |
| client   | libwww, libwww-perl                 |
| server   | libwww, Apache API, NSAPI           |
| cache    | browser cache, Akamai cache network |
| resolver | bind (DNS lookup library)           |
| tunnel   | SOCKS, SSL after HTTP CONNECT       |

すべての REST インタラクションはステートレスです。つまり、各リクエストには、それ以前のリクエストとは無関係に、コネクタがそのリクエストを理解するために必要なすべての情報が含まれています。この制限により、4 つの機能が実現されます。1) コネクタがリクエスト間でアプリケーションの状態を保持する必要がなくなるため、物理的なリソースの消費が抑えられ、スケーラビリティが向上します。2) 処理メカニズムが相互作用のセマンティクスを理解する必要なく、相互作用を並行して処理できます。

コネクタのインターフェースは、手続き型の呼び出しに似ていますが、パラメータと結果の受け渡しに重要な違いがあります。インパラメータは、リクエスト制御データ、リクエストの対象を示すリソース識別子、およびオプションの表現で構成されます。アウトパラメータは、レスポンス制御データ、オプションのリソースメタデータ、およびオプションの表現で構成されます。抽象的には、呼び出しは同期的に行われますが、インパラメータ、アウトパラメータともにデータストリームとして渡すことができます。つまり、パラメータの値が完全に判明する前に処理を呼び出すことができるため、大規模なデータ転送をバッチ処理する際のレイテンシーを回避することができます。

コネクタの種類には、主にクライアントとサーバーがある。両者の本質的な違いは、クライアントはリクエストを行うことで通信を開始するのに対し、サーバーはサービスへのアクセスを提供するために接続を待ち、リクエストに応答することです。コンポーネントには、クライアント・コネクタとサーバー・コネクタの両方が含まれる場合があります。

第 3 のコネクタータイプであるキャッシュコネクターは、クライアントまたはサーバーコネクターのインターフェイスに配置され、現在のインタラクションに対するキャッシュ可能なレスポンスを保存して、後で要求されたインタラクションに再利用できるようにします。キャッシュは、クライアントがネットワーク通信の繰り返しを避けるために使用することも、サーバーがレスポンスの生成プロセスの繰り返しを避けるために使用することもでき、いずれの場合もインタラクションのレイテンシーを短縮する役割を果たします。キャッシュは通常、それを使用するコネクタのアドレス空間内に実装される。

キャッシュコネクタの中には、キャッシュされたレスポンスを、レスポンスを最初に取得したクライアント以外のクライアントへの応答に使用できる、共有型のものもあります。共有キャッシュは、人気のあるサーバーの負荷に対する「フラッシュクラウド」の影響を軽減するのに効果的である。特に、企業のイントラネット内のユーザー、インターネットサービスプロバイダーの顧客、全国的なネットワークバックボーンを共有する大学など、大規模なユーザーグループをカバーするようにキャッシュが階層的に配置されている場合には効果的である。しかし、共有キャッシングは、キャッシュされたレスポンスが新しいリクエストで得られたものと一致しない場合、エラーになることもあります。REST は、絶対的な透明性が常に必要であると仮定するのではなく、キャッシュの動作における透明性の要求と、ネットワークの効率的な使用の要求とのバランスをとることを試みている。

キャッシュは、インターフェースが各リソースに固有のものではなく汎用的なものであるため、レスポンスのキャッシュ可能性を判断することができます。デフォルトでは、検索要求に対する応答はキャッシュ可能であり、他の要求に対する応答はキャッシュ不可能である。ある種のユーザー認証がリクエストの一部である場合、またはレスポンスが共有されるべきでないことを示している場合、レスポンスは非共有キャッシュによってのみキャッシュ可能となります。コンポーネントは、相互作用をキャッシュ可能、非キャッシュ可能、または限られた期間のみキャッシュ可能とマークする制御データを含むことによって、これらのデフォルトを上書きすることができる。

リゾルバは、部分的または完全なリソース識別子を、コンポーネント間の接続を確立するために必要なネットワークアドレス情報に変換する。例えば、ほとんどの URI には、リソースの命名機関を特定する仕組みとして、DNS ホスト名が含まれている。Web ブラウザは、リクエストを開始するために、URI からホスト名を抽出し、DNS リゾルバを利用してその機関のインターネットプロトコルアドレスを取得します。別の例としては、いくつかの識別スキーム（例えば、URN[124]）では、識別されたリソースにアクセスするために、仲介者が永久的な識別子をより一時的なアドレスに変換することが必要になります。1 つまたは複数の中間リゾルバを使用することで、インダイレクションによるリソース参照の寿命を向上させることができるが、そうすることでリクエストのレイテンシーが増加する。

コネクタタイプの最終形態はトンネルで、ファイアウォールや低レベルのネットワークゲートウェイなどの接続境界を越えて通信を中継するだけです。トンネルが REST の一部としてモデル化され、ネットワークインフラの一部として抽象化されていない唯一の理由は、REST コンポーネントの中には、アクティブなコンポーネントの動作からトンネルの動作に動的に切り替えるものがあるからです。主な例は、CONNECT メソッドのリクエストに応答してトンネルに切り替わる HTTP プロキシです[71]。これにより、クライアントは、プロキシを許可しない TLS などの異なるプロトコルを使用するリモートサーバと直接通信できるようになります。トンネルは、両端が通信を終了すると消滅します。

### 5.2.3 コンポーネント

表 5-3 にまとめた REST コンポーネントは、アプリケーション全体の動作の中での役割によってタイプ分けされています。

| コンポーネント | モダンな web 事例                    |
| -------------- | ------------------------------------ |
| origin server  | Apache httpd, Microsoft IIS          |
| gateway        | Squid, CGI, Reverse Proxy            |
| proxy          | CERN Proxy, Netscape Proxy, Gauntlet |
| user agent     | Netscape Navigator, Lynx, MOMspider  |

ユーザーエージェントは、クライアントコネクタを使用してリクエストを開始し、レスポンスの最終的な受信者となります。最も一般的な例は Web ブラウザで、情報サービスへのアクセスを提供し、アプリケーションのニーズに応じてサービスレスポンスをレンダリングします。

オリジン・サーバーは、サーバー・コネクターを使用して、リクエストされたリソースの名前空間を管理します。オリジンサーバーは、そのリソースを表現する決定的なソースであり、そのリソースの値を変更しようとするあらゆるリクエストの最終的な受信者でなければなりません。各オリジンサーバーは、リソース階層としてそのサービスへの一般的なインターフェースを提供します。リソースの実装の詳細は、インターフェースの後ろに隠されています。

仲介コンポーネントは、クライアントとサーバーの両方の役割を果たし、リクエストとレスポンスを可能な限り変換して転送します。プロキシコンポーネントは、他のサービスのインターフェースのカプセル化、データの変換、パフォーマンスの向上、セキュリティの保護などを行うために、クライアントによって選択される仲介者である。ゲートウェイ（リバースプロキシ）コンポーネントは、他のサービスのインターフェイスのカプセル化、データ変換、パフォーマンスの向上、セキュリティの強化のために、ネットワークまたはオリジンサーバーによって課される仲介者です。なお、プロキシとゲートウェイの違いは、クライアントがプロキシを使用するタイミングを決定することです。

## 5.3 REST のアーキテクチャビュー

REST のアーキテクチャ要素を個別に理解できたところで、アーキテクチャビュー[105]を使って、要素がどのように連携してアーキテクチャを形成しているかを説明することができます。REST の設計原理を明らかにするには、プロセス、コネクタ、データの 3 種類のビューが有効です。

### 5.3.1 プロセスビュー

アーキテクチャのプロセスビューは、主にシステムを流れるデータの経路を明らかにすることで、コンポーネント間の相互作用関係を引き出すのに有効です。残念ながら、実際のシステムの相互作用には膨大な数のコンポーネントが含まれているため、全体的なビューは詳細が見えなくなってしまいます。図 5-10 は、3 つの並列リクエストを処理しているときの、REST ベースのアーキテクチャのプロセスビューのサンプルです。

REST のクライアントとサーバーの関心事の分離は、コンポーネントの実装を簡素化し、コネクタセマンティクスの複雑さを軽減し、パフォーマンスチューニングの効果を向上させ、純粋なサーバーコンポーネントのスケーラビリティを向上させます。層状のシステム制約により、コンポーネント間のインターフェースを変更することなく、通信のさまざまなポイントに中間体（プロキシ、ゲートウェイ、ファイアウォール）を導入することができ、通信の変換を支援したり、大規模な共有キャッシングによりパフォーマンスを向上させることができます。REST は、メッセージを自己記述的にすることで、中間処理を可能にしています。リクエスト間のやりとりはステートレスで、セマンティクスや情報交換には標準的なメソッドやメディアタイプが使用され、レスポンスにはキャッシュ可能性が明示されています。

コンポーネントは動的に接続されるため、特定のアプリケーションアクションに対するコンポーネントの配置と機能は、パイプとフィルターのスタイルに似た特徴を持っています。REST のコンポーネントは双方向のストリームを介して通信しますが、各方向の処理は独立しているため、ストリーム変換器（フィルター）の影響を受けます。ジェネリック・コネクター・インターフェースにより、各リクエストやレスポンスのプロパティに基づいて、コンポーネントをストリーム上に配置することができます。

サービスは、仲介者の複雑な階層や複数の分散型オリジンサーバーを使用して実装することができます。REST のステートレスな性質により、各インタラクションは他のインタラクションから独立しているため、インターネット規模のアーキテクチャでは不可能な、コンポーネント全体のトポロジーを意識する必要がなく、コンポーネントは各リクエストのターゲットによって動的に決定される宛先または仲介者として機能することができます。コネクタは、通信の範囲内でお互いの存在を認識するだけでよいが、パフォーマンス上の理由から他のコンポーネントの存在と能力をキャッシュすることがある。

## 5.3.2 コネクタービュー

アーキテクチャのコネクタビューは、コンポーネント間の通信の仕組みに集中しています。REST ベースのアーキテクチャでは、一般的なリソース・インターフェースを定義する制約に特に関心があります。

クライアント・コネクタは、リクエストごとに適切な通信メカニズムを選択するために、リソース識別子を調べます。例えば、クライアントは、識別子がローカルリソースであることを示している場合、特定のプロキシコンポーネント（おそらくアノテーションフィルタとして機能するもの）に接続するように構成されるかもしれない。同様に、クライアントは、ある識別子のサブセットに対するリクエストを拒否するように設定することもできます。

REST は、通信を特定のプロトコルに制限するものではありませんが、コンポーネント間のインターフェースを制限するものであり、したがって、コンポーネント間で行われる可能性のある相互作用や実装上の仮定の範囲を制限するものでもあります。例えば、Web の主要な転送プロトコルは HTTP ですが、このアーキテクチャには、FTP [107]、Gopher [7]、WAIS [36]など、既存のネットワークサーバから発信されるリソースへのシームレスなアクセスも含まれています。これらのサービスとのインタラクションは、REST コネクタのセマンティクスに制限されています。この制約は、コネクタ・セマンティクスのための単一の汎用インターフェースの利点を維持するために、WAIS のような関連性フィードバック・プロトコルのステートフルな相互作用など、他のアーキテクチャの利点の一部を犠牲にしています。その代わり、ジェネリックなインターフェイスにより、単一のプロキシを介して多数のサービスにアクセスすることが可能になります。アプリケーションが他のアーキテクチャの追加機能を必要とする場合、Web アーキテクチャが「telnet」や「mailto」リソースとどのようにインターフェースするかと同様に、並行して実行される別のシステムとしてそれらの機能を実装し、呼び出すことができます。

## 5.3.3 データビュー

アーキテクチャのデータビューは、情報がコンポーネントを通過する際のアプリケーションの状態を明らかにします。REST は特に分散型の情報システムを対象としているため、アプリケーションを、ユーザーが目的のタスクを実行するための情報と制御手段のまとまった構造とみなします。例えば、オンライン辞書で単語を検索することは、仮想の博物館を見学することや、試験勉強のために授業のノートを見直すことと同様に、1 つのアプリケーションです。各アプリケーションは、基礎となるシステムの目標を定義し、それに基づいてシステムのパフォーマンスを測定することができます。

コンポーネントの相互作用は、動的にサイズ調整されたメッセージの形で行われます。コントロール・セマンティクスには小粒や中粒のメッセージが使用されますが、アプリケーション・ワークの大部分は、完全なリソース表現を含む大粒のメッセージによって達成されます。リクエストセマンティクスの最も一般的な形態は、リソースの表現を取得することであり（例：HTTP の「GET」メソッド）、これは多くの場合、後で再利用するためにキャッシュされます。

REST は、すべての制御状態を、インタラクションに応じて受信した表現に集約します。REST の目的は、現在のリクエスト以外のクライアントの状態をサーバーが把握する必要をなくすことで、サーバーの拡張性を高めることです。したがって、アプリケーションの状態は、保留中のリクエスト、接続されたコンポーネントのトポロジー（バッファリングされたデータをフィルタリングしている場合もある）、これらのコネクタに対するアクティブなリクエスト、これらのリクエストに応答する表現のデータフロー、およびユーザーエージェントが受信するこれらの表現の処理によって定義されます。

アプリケーションは、未処理のリクエストがなく、保留中のリクエストがなく、現在のリクエストに対するすべてのレスポンスが完全に受信されているか、表現データストリームとして扱えるところまで受信されている場合には、定常状態に達します。ブラウザアプリケーションの場合、この状態は、主な表現と、インライン画像、埋め込みアプレット、スタイルシートなどの補助的な表現を含む「Web ページ」に相当します。アプリケーションの定常状態の重要性は、ユーザーが感じるパフォーマンスとネットワークリクエストトラフィックのバースト性の両方に影響を与えることにあります。

ブラウザアプリケーションのユーザーが感じるパフォーマンスは、定常状態間のレイテンシーによって決まります。つまり、あるウェブページでハイパーメディアリンクを選択してから、次のウェブページで使用可能な情報がレンダリングされるまでの期間です。そのため、ブラウザのパフォーマンスを最適化するには、この通信レイテンシーを短縮することが中心となります。

REST ベースのアーキテクチャは、主にリソースの表現を転送することで通信を行うため、通信プロトコルの設計と表現データフォーマットの設計の両方がレイテンシーに影響を与えます。受信したレスポンスデータを段階的にレンダリングできるかどうかは、メディアタイプの設計と、各表現内のレイアウト情報（インラインオブジェクトの視覚的寸法）の利用可能性によって決まります。

面白い観察結果として、最も効率的なネットワークリクエストは、ネットワークを使用しないリクエストであるということがあります。つまり、キャッシュされたレスポンスを再利用することで、アプリケーションのパフォーマンスが大幅に向上するということです。キャッシュを使用すると、ルックアップのオーバーヘッドのために個々のリクエストに多少のレイテンシーが追加されますが、わずかな割合のリクエストでも使用可能なキャッシュヒットが得られれば、平均的なリクエストのレイテンシーは大幅に減少します。

アプリケーションの次の制御状態は、最初にリクエストされたリソースの表現に存在するため、その最初の表現を得ることが優先されます。したがって、REST のインタラクションは、"最初に応答し、後で考える "プロトコルによって改善されます。言い換えれば、コンテンツレスポンスを送信する前に機能のネゴシエーションなどを行うために、ユーザのアクションごとに複数のインタラクションを必要とするプロトコルは、最適と思われるものを最初に送信し、最初のレスポンスが満足のいくものではなかった場合にクライアントが検索できるように代替品のリストを提供するプロトコルに比べて、知覚的に遅くなります。

アプリケーションの状態は、ユーザーエージェントによって制御、保存され、複数のサーバーからの表現で構成することができます。これにより、サーバは状態を保存することによるスケーラビリティの問題から解放されるだけでなく、ユーザは状態を直接操作したり（例：Web ブラウザの履歴）、状態の変化を予測したり（例：リンクマップや表現のプリフェッチ）、あるアプリケーションから別のアプリケーションにジャンプしたり（例：ブックマークや URI 入力ダイアログ）することができます。

したがって、モデルアプリケーションは、現在の表現セットに含まれる代替的な状態遷移を調べ、その中から選択することで、ある状態から次の状態に移行するエンジンとなります。驚くことではありませんが、これはハイパーメディア・ブラウザのユーザー・インターフェースにぴったり一致します。しかし、このスタイルでは、すべてのアプリケーションがブラウザであるとは想定していません。実際，アプリケーションの詳細はジェネリック・コネクタ・インタフェースによってサーバから隠されているため，ユーザ・エージェントは，インデックス・サービスのために情報検索を行う自動化されたロボットであったり，特定の基準に一致するデータを探すパーソナル・エージェントであったり，壊れた参照や修正されたコンテンツのために情報をパトロールするのに忙しいメンテナンス・スパイダーであったりする可能性があります．

## 5.4 関連作品

Bass ら[9]は、World Wide Web のアーキテクチャについて 1 章を割いていますが、その記述は、CERN/W3C が開発した libwww（クライアントとサーバのライブラリ）と Jigsaw ソフトウェア内の実装アーキテクチャのみを対象としています。これらの実装は、Web のアーキテクチャ設計とその理論的根拠に精通した人々によって開発されているため、REST の設計上の制約の多くを反映していますが、実際の WWW アーキテクチャは、どのような実装にも依存しません。現代の Web は、その標準的なインターフェースやプロトコルによって定義されており、それらのインターフェースやプロトコルが特定のソフトウェアにどのように実装されているかは関係ありません。

REST のスタイルは、既存の多くの分散プロセスパラダイム[6, 50]、通信プロトコル、およびソフトウェア分野から引用されています。REST のコンポーネントのインタラクションは、レイヤー化されたクライアント・サーバースタイルで構成されていますが、ジェネリックなリソースインターフェイスの制約が加わることで、代替可能性や仲介者による検査の機会が生まれます。要求と応答は、リモートの呼び出しスタイルのように見えますが、REST メッセージは、実装識別子ではなく、概念的なリソースを対象としています。

Web アーキテクチャを分散ファイルシステムの一形態（例：WebNFS）や分散オブジェクトシステムとしてモデル化する試みがいくつかなされている[83]。しかし、これらのモデルは、様々な Web リソースタイプや実装戦略を「興味のないもの」として除外しています。実際には、それらの存在は、このようなモデルの基礎となる仮定を無効にするものです。REST がうまく機能しているのは、リソースの実装を特定の定義済みモデルに限定しないため、各アプリケーションが自分のニーズに最も適した実装を選択でき、ユーザーに影響を与えることなく実装の交換が可能だからです。

リソースの表現を消費側のコンポーネントに送信するインタラクション方式は、イベントベースインテグレーション（EBI）スタイルとの類似点があります。主な違いは、EBI スタイルがプッシュベースであることです。状態を保持するコンポーネント（REST のオリジンサーバーに相当）は、状態が変化するたびにイベントを発行しますが、実際にコンポーネントがそのようなイベントに関心を持っているかどうかは関係ありません。REST スタイルでは、消費側のコンポーネントは通常、表現をプルします。これは、単一のリソースを監視したい単一のクライアントとして見た場合には効率的ではありませんが、ウェブの規模が大きいため、規制のないプッシュモデルは実現不可能です。

コンポーネント、コネクタ、および表現の明確な概念を持つ REST スタイルを Web で原則的に使用することは、C2 アーキテクチャスタイルと密接に関連しています[128]。C2 スタイルは、基板の独立性を得るためにコネクタを構造的に使用することに重点を置くことで、分散型の動的なアプリケーションの開発をサポートします。C2 アプリケーションは、状態変化やリクエスト メッセージの非同期通知に依存しています。他のイベントベースのスキームと同様に、C2 は名目上はプッシュベースですが、C2 アーキテクチャは、リクエストの受信時に通知を発するだけで REST のプルスタイルで動作することもできます。ただし、C2 スタイルには、ジェネリック リソース インターフェイス、保証されたステートレス インタラクション、キャッシュの本質的なサポートなど、REST の仲介者に優しい制約がありません。

## 5.5 概要

本章では、分散ハイパーメディアシステムのアーキテクチャスタイルである REST（Representational State Transfer）を紹介しました。REST は、コンポーネントの相互作用のスケーラビリティ、インターフェースの汎用性、コンポーネントの独立した配置、および相互作用の待ち時間を短縮し、セキュリティを強化し、レガシーシステムをカプセル化するための仲介コンポーネントを重視した一連のアーキテクチャ制約を提供します。REST を導いているソフトウェアエンジニアリングの原則と、その原則を維持するために選択された相互作用制約について、他のアーキテクチャスタイルの制約と対比させながら説明しました。

次の章では、REST を最新の Web アーキテクチャの設計、仕様、および展開に適用した経験と教訓を通して、REST アーキテクチャの評価を紹介します。この作業には、ハイパーテキスト転送プロトコル (HTTP/1.1) と Uniform Resource Identifiers (URI) の現在のインターネット標準トラック仕様の作成、および libwww-perl クライアントプロトコルライブラリと Apache HTTP サーバによるアーキテクチャの実装が含まれます。

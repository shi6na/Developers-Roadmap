---
marp: true
---

# Roy Fieldings Paper

---

# Abstract

- 現代(2000年)のWebアークテクチャのモデルが必要
- 目的は、アーキテクチャに求められる機能的、性能的、社会的特性を得ること。
- アーキテクチャスタイルとは、名前が付けられ、調整された一連のアーキテクチャ制約のこと。
- この論文では、「アーキテクチャスタイルを使ってフレームワークを定義」して、「アプリケーションソフトウェアのアーキテクチャ設計にどのように利用できるか」を示している。

---

1. 「REST（Representational State Transfer）」というアーキテクチャスタイルを
紹介し、現代のWebにRESTがどう活用されているかを説明する。

2. RESTが重視するもの

- コンポーネント・インタラクションの拡張性
- インターフェースの汎用性
- コンポーネントを独立して配置することができること
- インタラクションの待ち時間を低減するための中間的なコンポーネント
- セキュリティの強化
- レガシーシステムをカプセル化する

---

3. RESTの軸になっているソフトウェア・エンジニアリングの原則と、その原則を維持するために選択されたインタラクション制約について、他のアーキテクチャスタイルと対比させながら説明する。

4. 最後に、HTTPとURIの標準規格の設計に適用し、その後Webクライアントおよびサーバへの展開から得られた教訓について述べる。

---

# introduction

- ソフトウェアのプロジェクトでは、最新の流行を採用することから始まり、あとになって要件にそれが必要であるかどうかが判明することがよくある。
- アーキテクチャ制約のセットがなぜ有用なのかを理解していないことに起因する。->理解する必要がある。
- ソフトウェアとネットワークという2つの研究分野の境界にある接合部を探る。アーキテクチャの設計を理解し、アーキテクチャ制約を原理的に使用して評価することで、アーキテクチャ本来の地位からを得ることが目的。

---

- 3章：アーキテクチャを理解するためのフレームワークを定義し、設計にどのように利用出来るかを明らかにする。
- 4章：webの要件を理解する。
- 5章：webのための『REST』アーキテクチャを紹介。
- 6章：6年間RESTがどう活用されてきたか

---

本論文が情報・コンピュータ科学の分野におけるソフトウェア研究に貢献するもの

- ソフトウェアアーキテクチャを記述するための一貫した用語集
- ソフトウェアアーキテクチャを理解するためのフレームワーク
- アーキテクチャスタイルを、分散ハイパーメディアシステムのアーキテクチャに適用した場合に、誘発されるアーキテクチャ特性によって分類
- 「REST」、および 現代のWWWのためのアーキテクチャの設計におけるRESTの適用と評価。

---

# 5章：REST

---

RESTは以下のプロセスで開発された。

- 設計者がシステムのニーズを制約なしに全体として把握するところから始め、設計空間を区別する。
- システムの動作に影響を与える力がシステムと調和して自然に流れるようにするために、システムの要素を段階的に特定して制約を適用する。

NullスタイルをつかってRESTを説明する。

- Nullスタイル：制約の空のセット。コンポーネント間に識別可能な境界が存在しないシステムを表している。

---

# RESTの特性

---

# クライアントサーバ型

- すごい
- 懸念事項の分離ができる
  - UIの問題とデータ・ストレージの問題を分離させる
- UIの移植性を向上させ、サーバコンポーネントを単純化する → スケーラビリティ（拡張性）の向上
- webに重要なのは、分離によりコンポーネントを独立して進化させ、複数の組織ドメインのインターネット規模の要件をサポートすること


---

# ステートレス

セッションの状態はすべてクライアント側で保持される。

- クライアント→サーバへのリクエストでは、サーバに保存されている情報を利用することができないため。
- ステートレス化により、可用性・信頼性・スケーラビリティという特性を得る
  - 可用性：単一のリクエストデータのみで、監視システムがリクエストの完全な性質を判断できる
  - 信頼性：部分的な故障からの回復作業が容易になる
  - スケーラビリティ：リクエスト間で状態を保存する必要がないため、サーバコンポーネントが迅速にリソースを開放できる
- また、サーバがリクエスト間のリソース使用を管理する必要がないため、実装がさらにシンプルになる。

---

# ステートレス

デメリット

- ネットワークパフォーマンスが低下する可能性
  - 一連のリクエストで送信される反復的なデータが増えるため
- アプリケーションの一環した動作に対するサーバのコントロールが弱くなる
  - アプリケーションが複数クライアントのバージョンに対応して実装されているかどうかに依存するため

---

# キャッシュ

- リクエストに対するレスポンス内のデータを、キャッシュ可能/不可能とラベル付することを要求する
- キャッシュ可能な場合、クライアントキャッシュには、そのレスポンスデータを後の同等のリクエストに再利用する権利が与えられる。
- 一部のインタラクションを完全〜部分的に排除出来る可能性があり、一連のインタラクションの平均レイテンシーを短縮することで、効率性、スケーラビリティ、ユーザが感じるパフォーマンスを向上できる
- トレードオフとして、キャッシュが古い場合、キャッシュは信頼性を低下させる可能性がある。

---

# 統一されたフォーマット

- RESTの特徴は、コンポーネント間の統一されたインターフェースを重視していること。
- インターフェースを汎用化させることで、システム全体のアーキテクチャが簡素化され、相互作用の可視性が向上する。
- トレードオフとして、効率性を低下させる。
- 大規模なハイパーメディアのデータ転送に効率的に対応できるように設計されているため、他の形式のアーキテクチャには不適切。

---

# レイヤードシステム

- システムに関する知識を1つの層に限定することで、システム全体の複雑さに制限をかけ、基板の独立性を高めることができる。
- 従来のサービスをカプセル化することで、コンポーネントを簡素化することができる。
- 中間体を利用することで、複数のネットワークやプロセッサにまたがるサービスの負荷分散を可能にし、システムのスケーラビリティを向上させる。

---

# レイヤードシステム

デメリット

- データの処理にオーバーヘッドとレイテンシが加わり、パフォーマンスが低下すること
- キャッシュ制約をサポートするネットワークベースのシステムでは、中間層での共有キャッシュの利点により、この問題は相殺される。
- 共有キャッシュを組織ドメインの境界に配置することで、パフォーマンスが大幅に向上する。

---

# コード・オン・デマンド

- アプレットやスクリプトの形でコードをダウンロードして実行することで、クライアントの機能を拡張することができる。
- これにより、事前に実装しなければならない機能の数が減り、クライアントがシンプルになる。
- デプロイ後に機能をダウンロードできるようにすることで、拡張性が向上する。
- ただし、視認性が低下するため、RESTでは任意の制約となっている。

---

# アーキテクチャ要素

---

# データ要素

| データ要素 | モダンなweb事例 |
| --- | --- |
| リソース | ハイパーテキスト参照の意図された概念的ターゲット |
| リソース識別子 | URL, URN |
| 表現 | HTML 文書, JPEG 画像 |
| 表現メタデータ | media type、last-modified time |
| リソースメタデータ | source link, alternates, バリエーション（vary） |
| コントロールデータ | if-modified-since, cache-control（httpヘッダ） |

---


# リソースとリソース識別子

- RESTにおける主要な情報を抽象化したものがリソース。
- ドキュメントや画像、サービス、仮想ではないオブジェクト（例：人）など、名前をつけることができる情報はすべてリソース。
- 作者がハイパーテキストで参照する対象となる可能性のある概念はすべて、リソースの定義に当てはまらなければならない。

---

- リソースを抽象的に定義することで、以下のようなWebアーキテクチャの主要な機能を実現している。
  1. 多くの情報源をタイプや実装で区別せず包含することで、汎用性を提供する
  1. 参照を表現に後から結合することができ、リクエストの特性に基づいて[コンテンツネゴシエーション](https://developer.mozilla.org/ja/docs/Web/HTTP/Content_negotiation)を行うことができる
  1. 概念を参照することができるため、表現が変わるたびに既存のリンクをすべて変更する必要がない

---

# 表現

- 一連のバイトと、それを記述するメタデータのこと
- これをコンポーネント間で転送することにより、リソースに対してアクションを実行する
- 例：ドキュメント、ファイル、インスタンスなど

---

| なまえ | せつめい |
| --- | --- |
| メタデータ | 名前と値のペア  <br>名前は値の構造とセマンティクスを定義する規格に対応 |
| 応答メッセージ | 表現メタデータとリソースメタデータの<br>両方が含まれることがある |
| 制御データ | リクエストされるアクションやレスポンスの意味など、<br>コンポーネント間のメッセージの目的を定義。<br>リクエストをパラメータ化したり、一部の接続要素の<br>デフォルトの動作を上書きするためにも使用される。<br>e.g.キャッシュの動作は制御データによって変更する事ができる |

---

- 表現のデータ形式は「メディアタイプ」。
- メッセージに含むことができ、制御データとメディアタイプの性質に応じて受信者が処理することができる。
- 自動処理を目的としたあものと、ユーザが閲覧するためにレンダリングすることを目的としたものがある。
  - その両方が可能な「複合メディアタイプ」も存在し、1つのメッセージに複数の表現を含むために使用できる。

---

- メディアタイプの設計はパフォーマンスに直接影響を与える。
- 受信者がレンダリングを開始する前に受信しなければならないデータがあると、インタラクションの待ち時間が長くなる。
- 例えば、最も重要なレンダリング情報を前面に配置し、残りの情報を受信している間に最初の情報をレンダリングできるようなデータ・フォーマットは、レンダリングする前にすべてを受信しなければならないものよりも、パフォーマンスがはるかに優れている。

---

- 表現のレンダリング能力は、コンテンツの選択によっても影響を受ける。
- 動的なサイズのテーブルや埋め込みオブジェクトの寸法をレンダリング前に決定しなければならない場合、レイテンシが増加する。

---

# コネクタ

- RESTでは、さまざまなタイプの**コネクタ**を使用して、リソースへのアクセスやリソース表現の転送などのアクティビティをカプセル化している。
- コネクタは、コンポーネントの通信のための抽象的なインターフェースを提供し、関心事を明確に分離し、リソースや通信メカニズムの基本的な実装を隠すことで、シンプルさを向上させる。（カプセル化）
- 汎用的なインターフェースは、代替を可能にする。ユーザがシステムにアクセスする唯一の手段が抽象的なインターフェースを介したものであれば、ユーザに影響を与えることなく実装を置き換えることができる。
- コネクタはコンポーネントのネットワーク通信を管理するため、複数のインタラクションで情報を共有することができ、効率と応答性を向上させる。

---

| コネクタ | モダンなweb事例 |
| ---  | --- |
| client | libwww, libwww-perl |
| server |  libwww, Apache API, NSAPI |
| cache | browser cache, Akamai cache network |
| resolver | bind(DNS lookup library) |
| tunnel | SOCKS, SSL after HTTP CONNECT |

---

- すべてのRESTインタラクションはスレートレスである。
- つまり、各リクエストには、それ以前のリクエストとは無関係に、コネクタがそのリクエストを理解するために必要なすべての情報が含まれている。
- この制限により、4つの機能が実現される。

---

1. リクエスト間でコネクタがアプリケーションの状態を保持する必要がないため、物理リソースの消費を抑え、スケーラビリティを向上させることができる。
1. 処理機構が相互作用のセマンティクスを理解することを必要とせずに、相互作用を並列に処理することができる。
1. サービスが動的に再配置される場合に必要となる、仲介者によるリクエストの単独での表示と理解を可能にする。
1. キャッシュされた応答の再利用性の要因となりうるすべての情報が、各リクエストに存在することを強制する。

---

- コネクタのインターフェースは、手続き型の呼び出しに似ているが、パタメータと結果の受け渡しに重要な違いがある。
- インパラメータは、リクエスト制御データ、リクエストの対象を示すリソース識別子、オプションの表現で構成される。
- アウトパラメータは、レスポンス制御データ、オプションのリソースメタデータ、オプションの表現で構成される。
  - どちらもデータストリームとして渡す事ができる。
  - →パラメータの値が完全に判明する前に処理を呼び出すことができるため、大規模なデータ転送をバッチ処理する際の遅延を回避できる。

---

## クライアント・サーバ

- コネクタの種類には、主に**クライアント**と**サーバ**がある。
- クライアントはリクエストを行うことで通信を開始する。
- サーバはサービスへのアクセスを提供するために接続を持ち、リクエストに応答する。
- コンポーネントには、クライアント・コネクタとサーバー・コネクタの両方が含まれる場合がある。

---

## キャッシュ

- クライアントまたはサーバーコネクターのインターフェイスに配置され、使用するコネクタのアドレス空間内に実装される。
- 現在のインタラクションに対するキャッシュ可能なレスポンスを保存して、後で要求されたインタラクションに再利用できるようにするもの。
- クライアントがネットワーク通信の繰り返しを避けるために使用することも、サーバーがレスポンスの生成プロセスの繰り返しを避けるために使用することもでき、いずれの場合もインタラクションのレイテンシーを短縮する役割を果たす。

---

### 共有キャッシュ

- キャッシュコネクタの中には、クライアント共有型のものもある。
  - キャッシュされたレスポンスを、レスポンスを取得したクライアント以外のクライアントへの応答に使用できる。
- 共有キャッシュは、人気のあるサーバーの負荷に対する「[フラッシュクラウド](https://ja.wikipedia.org/wiki/%E3%82%B9%E3%83%A9%E3%83%83%E3%82%B7%E3%83%A5%E3%83%89%E3%83%83%E3%83%88%E5%8A%B9%E6%9E%9C)」の影響を軽減するのに効果的である。
- 特に、企業のイントラネット内のユーザー、インターネットサービスプロバイダーの顧客、全国的なネットワークバックボーンを共有する大学など、大規模なユーザーグループをカバーするようにキャッシュが階層的に配置されている場合には効果的である。
  - ただし、キャッシュされたレスポンスが新しいリクエストで得られたものと一致しない場合、エラーになることもある。
- RESTは、キャッシュの動作における透明性の要求と、ネットワークの効率的な使用の要求とのバランスをとることを試みている。

---

- キャッシュは、各リソースに固有のものではなく汎用的なものであるため、レスポンスのキャッシュ可能性を判断することができる。
- デフォルトでは、検索要求に対する応答はキャッシュ可能であり、他の要求に対する応答はキャッシュ不可能である。
- 「ある種のユーザー認証がリクエストの一部である」場合、または「レスポンスが共有されるべきでないことを示している」場合は、レスポンスは非共有キャッシュでのみキャッシュ可能となる。
- コンポーネントは、キャッシュ可能、非キャッシュ可能、または限られた期間のみキャッシュ可能とマークする制御データを含むことによって、これらのデフォルトを上書きすることができる。

---

## リゾルバ

- 部分的または完全なリソース識別子を、コンポーネント間の接続を確立するために必要なネットワークアドレス情報に変換する。
- 例：ほとんどのURIには、リソースの命名機関を特定する仕組みとして、DNSホスト名が含まれている。
  - → Webブラウザは、リクエストを開始するために、URIからホスト名を抽出し、DNSリゾルバを利用してその機関のインターネットプロトコルアドレスを取得する。
- 別の例としては、いくつかの識別スキーム（e.g.URN）では、識別されたリソースにアクセスするために、仲介者が永久的な識別子をより一時的なアドレスに変換することが必要になる。
- 中間リゾルバを使用することで、リソース参照の寿命を向上させることができるが、リクエストのレイテンシーは増加する。

---

## トンネル

- FWや低レベルのネットワークゲートウェイなどの接続境界を越えて通信を中継する。
- 例：CONNETCTメソッドのリクエストに応答してトンネルに切り替わるHTTPプロキシ。
  - クライアントはプロキシを許可しないTLSなどの異なるプロトコルを使用するリモートサーバと直接通信できるようになる。
- 両端が通信を終了すると消滅する。

---

# コンポーネント

アプリケーション全体の動作の中での役割によってタイプ分けされている。

| コンポーネント | モダンなweb事例 |
| --- | --- |
| origin server | Apache httpd, Microsoft IIS |
| gateway | Squid, CGI, Reverse Proxy |
| proxy | CERN Proxy, Netscape Proxy, Gauntlet |
| user agent | Netscape Navigator, Lynx, MOMspider |

---

## user agent

- クライアントコネクタを使用してリクエストを開始し、レスポンスの最終的な受信者となる。
- 最も一般的な例はWebブラウザで、情報サービスへのアクセスを提供し、アプリケーションのニーズに応じてサービスレスポンスをレンダリングする。

---

## origin server

- サーバー・コネクターを使用して、リクエストされたリソースの名前空間を管理する。
- そのリソースを表現する決定的なソースであり、そのリソースの値を変更しようとするあらゆるリクエストの最終的な受信者でなければならない。
- 各オリジンサーバーは、リソース階層としてそのサービスへの一般的なインターフェースを提供する。
- リソースの実装の詳細は、インターフェースの後ろに隠されている。

---

## gateway, proxy（仲介コンポーネント）

- クライアントとサーバーの両方の役割を果たし、リクエストとレスポンスを可能な限り変換して転送する。
- proxy：他のサービスのインターフェースのカプセル化、データの変換、パフォーマンスの向上、セキュリティの保護などを行うために、クライアントによって選択される仲介者である。
- gateway（リバースプロキシ）：他のサービスのインターフェイスのカプセル化、データ変換、パフォーマンスの向上、セキュリティの強化のために、ネットワークまたはオリジンサーバーによって課される仲介者である。
- プロキシとゲートウェイの違いは、プロキシはクライアントが使用するタイミングを決定することにある。

---

# アーキテクチャビュー

---

- アーキテクチャビューをつかって、要素がどのように連携してアーキテクチャを形成しているかを説明できる。
- RESTの設計原則を明らかにするには、プロセス、コネクタ、データの3種類のビューが有効。

---

## プロセスビュー

- 主にシステムを流れるデータの経路を明らかにすることで、コンポーネント間の相互作用関係を引き出すのに有効です。
- 残念ながら、実際のシステムの相互作用には膨大な数のコンポーネントが含まれているため、全体的なビューは詳細が見えなくなってしまいます。

---

### クライアント・サーバー

- 下記により純粋なサーバーコンポーネントのスケーラビリティを向上させる。
  - コンポーネントの実装を簡素化
  - コネクタセマンティクスの複雑さを軽減
  - パフォーマンスチューニングの効果を向上

- 層状のシステム制約により、コンポーネント間のインターフェースを変更することなく、通信のさまざまなポイントに中間体（プロキシ、ゲートウェイ、ファイアウォール）を導入することができる。
- 通信の変換を支援したり、大規模な共有キャッシングによりパフォーマンスを向上させる。

---

- メッセージを自己記述的にすることで、中間処理が可能。
  - リクエスト間のやりとりはステートレス。
  - セマンティクスや情報交換には標準的なメソッドやメディアタイプが使用され、レスポンスにはキャッシュ可能性が明示されている。

---

### コンポーネント

- コンポーネントは動的に接続されるため、特定のアプリケーションアクションに対するコンポーネントの配置と機能は、パイプとフィルターのスタイルに似た特徴を持つ。
- RESTのコンポーネントは双方向のストリームを介して通信するが、各方向の処理は独立しているため、ストリーム変換器（フィルター）の影響を受ける。
- ジェネリック・コネクター・インターフェースにより、各リクエストやレスポンスのプロパティに基づいて、コンポーネントをストリーム上に配置することができる。

---

### サービス

- 仲介者の複雑な階層や複数の分散型オリジンサーバーを使用して実装することができる。
- RESTのステートレスな性質により、インターネット規模のアーキテクチャでは不可能な、コンポーネント全体のトポロジーを意識する必要がなく、コンポーネントは各リクエストのターゲットによって動的に決定される宛先または仲介者として機能することができる。
- コネクタは、通信の範囲内でお互いの存在を認識するだけでよいが、パフォーマンス上の理由から他のコンポーネントの存在と能力をキャッシュすることがある。

---

## コネクタビュー

- コンポーネント間の通信の仕組みに集中している。
- RESTベースのアーキテクチャでは、一般的なリソース・インターフェースを定義する制約に特に関心がある。

---

### クライアント・コネクタ

- リクエストごとに適切な通信メカニズムを選択するために、リソース識別子を調べる。
- 例えば、クライアントは、識別子がローカルリソースであることを示している場合、特定のプロキシコンポーネント（おそらくアノテーションフィルタとして機能するもの）に接続するように構成されるかもしれない。
- 同様に、クライアントは、ある識別子のサブセットに対するリクエストを拒否するように設定することもできる。

---

- RESTは、コンポーネント間のインターフェースを制限する。
  - コンポーネント間で行われる可能性がある相互作用や実装上の仮定の範囲を制限。
  - 例えば、Webの主要な転送プロトコルであるHTTPには、FTP、Gopher、WAIS など、既存のネットワークサーバから発信されるリソースへのシームレスなアクセスも含まれている。
- これらのサービスとのインタラクションは、RESTコネクタのセマンティクスに制限されている。
- この制約は、コネクタ・セマンティクスのための単一の汎用インターフェースの利点を維持するために、WAISのような関連性フィードバック・プロトコルのステートフルな相互作用など、他のアーキテクチャの利点の一部を犠牲にしている。
- その代わり、ジェネリックなインターフェイスにより、単一のプロキシを介して多数のサービスにアクセスすることが可能。

---

- アプリケーションが他のアーキテクチャの追加機能を必要とする場合、「telnet」や「mailto」リソースに対するインターフェースと同じように、並行して実行される別のシステムとして、Webアーキテクチャがそれらの機能を実装し、呼び出すことができる。

---

## データビュー

- 情報がコンポーネントを通過する際のアプリケーションの状態を明らかにする。
- RESTは特に分散型の情報システムを対象としているため、アプリケーションを「ユーザーが目的のタスクを実行するための情報と制御手段のまとまった構造」とみなす。
- 例えば、オンライン辞書で単語を検索することは、仮想の博物館を見学することや、試験勉強のために授業のノートを見直すことと同様であり、1つのアプリケーションでもある。
- 各アプリケーションは、基礎となるシステムの目標を定義し、それに基づいてシステムのパフォーマンスを測定することができる。

---

- コンポーネントの相互作用は、動的にサイズ調整されたメッセージの形で行われる。
- コントロール・セマンティクスには小粒や中粒のメッセージが使用されるが、アプリケーション・ワークの大部分は、完全なリソース表現を含む大粒のメッセージによって達成される。
- リクエストセマンティクスの最も一般的な形態は、リソースの表現を取得することであり（例：HTTPの「GET」メソッド）、これは多くの場合、後で再利用するためにキャッシュされる。

---

- RESTは、すべての制御状態を、インタラクションに応じて受信した表現に集約する。
- RESTの目的は、現在のリクエストのクライアントの状態の把握に集中させることで、サーバーの拡張性を高めることである。
- したがって、アプリケーションの状態は、
  - 保留中のリクエスト
  - 接続されたコンポーネントのトポロジー（バッファリングされたデータをフィルタリングしている場合もある）
  - これらのコネクタに対するアクティブなリクエスト
  - これらのリクエストに応答する表現のデータフロー
  - ユーザーエージェントが受信するこれらの表現の処理

によって定義される。

---

- アプリケーションは、
  - 未処理・保留中のリクエストがない
  - 現在のリクエストに対するすべてのレスポンスが完全に受信されている
  - もしくは表現データストリームとして扱えるところまで受信されている

  上記の場合に、定常状態（静的な状態）に達する。
- ブラウザアプリケーションの場合、この状態は、主な表現と、インライン画像、埋め込みアプレット、スタイルシートなどの補助的な表現を含む「Webページ」に相当する。
- アプリケーションの定常状態は、ユーザーが感じるパフォーマンスとネットワークリクエストトラフィックのバースト性の両方に影響を与える。

---

- ブラウザアプリケーションにおいてユーザーが感じるパフォーマンスは、定常状態間のレイテンシーによって決まる。
  - →あるウェブページでハイパーメディアリンクを選択してから、次のウェブページで使用可能な情報がレンダリングされるまでの期間。
- そのため、ブラウザのパフォーマンスを最適化するには、この通信レイテンシーを短縮することが中心となる。

---

- RESTベースのアーキテクチャは、主にリソースの表現を転送することで通信を行うため、通信プロトコルの設計と表現データフォーマットの設計の両方がレイテンシーに影響を与える。
- 受信したレスポンスデータを段階的にレンダリングできるかどうかは、メディアタイプの設計と、各表現内のレイアウト情報（インラインオブジェクトの視覚的寸法）の利用可能性によって決まる。（？）

---

- 面白い観察結果としてあげられているのは、最も効率的なネットワークリクエストは、**ネットワークを使用しないリクエスト**ということである。
- つまり、**キャッシュされたレスポンスを再利用**することで、アプリケーションのパフォーマンスが大幅に向上するということである。
- キャッシュを使用すると、キャッシュを探すオーバーヘッドで個々のリクエストに多少のレイテンシーが追加されるが、わずかな割合のリクエストでも使用可能なキャッシュヒットが得られれば、平均的なリクエストのレイテンシーは大幅に減少する。

---

- アプリケーションの次の制御状態は、最初にリクエストされたリソースの表現に存在するため、その最初の表現を得ることが優先される。
- したがって、RESTのインタラクションは、"最初に応答し、後で考える" プロトコルによって改善される。
  - コンテンツレスポンスを送信する前に、機能のネゴシエーション（交渉）などを行うために、ユーザのアクションごとに複数のインタラクションを必要とするプロトコル
  - 最適と思われるものを最初に送信し、最初のレスポンスが満足のいくものではなかった場合にクライアントが検索できるように代替品のリストを提供するプロトコル

  後者の方が知覚的に速くなる。

---

- アプリケーションの状態は、ユーザーエージェントによって制御、保存され、複数のサーバーからの表現で構成することができる。
- これにより、サーバは状態を保存することによるスケーラビリティの問題から解放されるだけでなく、ユーザは状態を直接操作したり（例：Webブラウザの履歴）、状態の変化を予測したり（例：リンクマップや表現のプリフェッチ）、あるアプリケーションから別のアプリケーションにジャンプしたり（例：ブックマークやURI入力ダイアログ）することができる。

---

- したがって、モデルアプリケーションは、現在の表現セットに含まれる代替的な状態遷移を調べ、その中から選択することで、ある状態から次の状態に移行するエンジンとなる。
- これはハイパーメディア・ブラウザのユーザー・インターフェースにぴったり一致する。
- しかし、このスタイルでは、すべてのアプリケーションがブラウザであるとは想定されていない。
- 実際、アプリケーションの詳細はジェネリック・コネクタ・インタフェースによってサーバから隠されているため、ユーザ・エージェントは、インデックス・サービスのために情報検索を行う自動化されたロボットであったり、特定の基準に一致するデータを探すパーソナル・エージェントであったり、壊れた参照や修正されたコンテンツのために情報をパトロールするのに忙しいメンテナンス・スパイダーであったりする可能性がある。

---

# 関連作品

---

- Bassら(L. Bass, P. Clements, and R. Kazman. Software Architecture in Practice. Addison Wesley, Reading, Mass., 1998.)は、World Wide Webのアーキテクチャについて1章を割いているが、その記述は、CERN/W3Cが開発したlibwww（クライアントとサーバのライブラリ）とJigsawソフトウェア内の実装アーキテクチャのみを対象としている。
- これらの実装は、Webのアーキテクチャ設計とその理論的根拠に精通した人々によって開発されているため、RESTの設計上の制約の多くを反映しているが、実際のWWWアーキテクチャは、どのような実装にも依存しない。
- 現代のWebは、その標準的なインターフェースやプロトコルによって定義されており、それらのインターフェースやプロトコルが特定のソフトウェアにどのように実装されているかは関係ない。

---

- Webアーキテクチャを分散ファイルシステムの一形態（例：WebNFS）や分散オブジェクトシステムとしてモデル化する試みがいくつかなされている。
- しかし、これらのモデルは、様々なWebリソースタイプや実装戦略を「興味のないもの」として除外している。
- 実際には、それらの存在は、このようなモデルの基礎となる仮定を無効にするものである。
- RESTがうまく機能しているのは、リソースの実装を特定の定義済みモデルに限定しないため、各アプリケーションが自分のニーズに最も適した実装を選択でき、ユーザーに影響を与えることなく実装の交換が可能なためである。

---

- リソースの表現を消費側のコンポーネントに送信するインタラクション方式は、イベントベースインテグレーション（EBI）スタイルと類似している。
- 主な違いは、EBIスタイルがプッシュベースで、RESTがプルベースであること。
- EBIは、状態を保持するコンポーネント（RESTのオリジンサーバーに相当）が、状態が変化するたびにイベントを発行するが、実際にコンポーネントがそのようなイベントに関心を持っているかどうかは関係がない。

---

- コンポーネント、コネクタ、および表現の明確な概念を持つRESTスタイルをWebで原則的に使用することは、C2アーキテクチャスタイルと密接に関連している。
- C2スタイルは、基板の独立性を得るためにコネクタを構造的に使用することで、分散型の動的なアプリケーションの開発をサポートする。
- C2アプリケーションは、状態変化やリクエスト メッセージの非同期通知に依存している。
- 他のイベントベースのスキームと同様に、C2は名目上はプッシュベースだが、C2アーキテクチャは、リクエストの受信時に通知を発するだけでRESTのプルスタイルで動作することもできる。
- ただし、C2スタイルには、汎用リソース インターフェイス、ステートレス インタラクションの保証、キャッシュの本質的なサポートなど、RESTに優しい制約が欠けている。
